
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Exterior Dirichlet radiation problem</title>
      <meta name="generator" content="MATLAB 7.8">
      <meta name="date" content="2009-11-10">
      <meta name="m-file" content="sph_trans_dir"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Exterior Dirichlet radiation problem</h1>
         <!--introduction-->
         <p>This tutorial shows how to use the toolbox <tt>NIHU</tt> to compute a simple acoustic radiation problem with Dirichlet boundary condition.
         </p>
         <!--/introduction-->
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Mesh generation</a></li>
               <li><a href="#2">Excitation</a></li>
               <li><a href="#3">Build cluster tree</a></li>
               <li><a href="#4">Sparse matrices</a></li>
               <li><a href="#5">FMM integration parameters</a></li>
               <li><a href="#6">BEM spatial quadrature and relative tree</a></li>
               <li><a href="#7">Solution</a></li>
            </ul>
         </div>
         <h2>Mesh generation<a name="1"></a></h2>
         <p>Use a toolbox function <tt>create_sphere_boundary</tt> to create a sphere mesh with given radius and division parameter. Determine maximal wavelength applicable to the mesh with
            a given element-per-wavelength ratio, using the toolbox function <tt>bemkmax</tt></p><pre class="codeinput">R = 1;      <span class="comment">% radius</span>
nR = 20;    <span class="comment">% division parameter</span>
mesh = create_sphere_boundary(R, nR);
ratio = 7;  <span class="comment">% element-per-wavelength ratio</span>
kmax = bemkmax(mesh, ratio);
k = min(kmax);

figure;
plot_mesh(mesh, kmax); view(3);
</pre><img vspace="5" hspace="5" src="sph_trans_dir_01.png" alt=""> <h2>Excitation<a name="2"></a></h2>
         <p>The excitation will be the pressure field of a point source located inside the sphere, slightly shifed from the center. Constant
            elements are used with one DOF located at the element centers, so the pressure is computed in the element center locations.
            For error analysis purposes, the analytical pressure derivative values are also computed. The element centers and normals
            are determined by a toolbox function <tt>centnorm</tt>, and the incident wave field is computed by the toolbox function <tt>incident</tt>.
         </p><pre class="codeinput">r0 = [-.2 0 0];                    <span class="comment">% location of the source monopole</span>
[cent, normal] = centnorm(mesh);   <span class="comment">% element centers and normals</span>
[ps, qs0] = incident(<span class="string">'point'</span>, r0, cent, normal, k);

figure;
plot_mesh(mesh, ps); view(3); colorbar;
</pre><img vspace="5" hspace="5" src="sph_trans_dir_02.png" alt=""> <h2>Build cluster tree<a name="3"></a></h2>
         <p>The cluster tree is built with the toolbox function <tt>clustertree</tt>. The depth of the tree is determined by the mesh's dimensions and the minimal dimensionless cluster size at the leaf level
            as
         </p>
         <p><img src="sph_trans_dir_eq43249.png" alt="$$ depth = \log_2 \frac{2kR}{kd_{\mathrm{min}}}$$"></p><pre class="codeinput">kdmin = 3;  <span class="comment">% minimal dimensionless cluster size at leaf level</span>
kD = 2*k*R; <span class="comment">% mesh dimension</span>
depth = round(log2(kD/kdmin));
[tree, fs, fr] = clustertree(depth, cent);
</pre><h2>Sparse matrices<a name="4"></a></h2>
         <p>The near field sparse bem matrices are determined by the toolbox function <tt>bemHG</tt>. The sparsity structure (location of nonzeros) of these matrices is determined using the cluster tree by the toolbox function
            <tt>nfij</tt></p><pre class="codeinput">[i, j] = nfij(tree(end).nearfield, tree(end).nodsou);
[Hnf, Gnf] = bemHG(mesh, k, <span class="string">'const'</span>, [], [i j]);

figure;
spy(Hnf);
</pre><img vspace="5" hspace="5" src="sph_trans_dir_03.png" alt=""> <h2>FMM integration parameters<a name="5"></a></h2>
         <p>The expansion lengths, the quadrature points over the unit sphere and the precomputed translation operators and interpolation
            matrices are generated by the toolbox function <tt>integpar</tt>.
         </p><pre class="codeinput">C = 3;  <span class="comment">% Accuracy parameter related to the expansion length</span>
I = integpar(tree, k, C);
</pre><h2>BEM spatial quadrature and relative tree<a name="6"></a></h2>
         <p>The Gaussian integration points and weights on the surface are computed by the toolbox function <tt>geo2gauss</tt>. The parameters of the function are the mesh and the quadrature points for triangles and quadrangles, respectively.
         </p>
         <p>In order to optimally use the C (MEX) code, the tree is converted into a relative tree that contains distances between entries
            rather than absolute locations.
         </p><pre class="codeinput">[t, gs, gn, w, gind] = geo2gauss(mesh, [3 9]);
[tr, rr, rs, ns] = reltree(tree, cent, fr, gs, fs(gind), gn);
</pre><h2>Solution<a name="7"></a></h2>
         <p>The right hand side of the linear system of equations is computed now. The near field part is computed by multiplication by
            the near field matrix, the far field contribution is computed by means of the MLFMA, using the toolbox function <tt>mpcont_Gq</tt>.
         </p><pre class="codeinput">Hp = Hnf*ps + -2*pi*ps + <span class="keyword">...</span>
    mpcont_Hp(rr, rs, ns, ps(gind).*w, tr, I, k, fs(gind), fr);
</pre><p>The iterative solution of the system of equations is computed by the toolbox function <tt>my_gmres</tt>, where the matrix-vector products are evaluated by the toolbox function <tt>gmres_iter_dirichlet</tt>.
         </p><pre class="codeinput">m = 100;        <span class="comment">% max. number of iterations</span>
tol = 1e-3;     <span class="comment">% prescribed backward relative tolerance</span>
[qs, eps] = my_gmres(<span class="keyword">...</span>
    @(q) gmres_iter_dirichlet(q, Gnf, rr, rs, w, gind, tr, I, k, fs, fr),<span class="keyword">...</span>
    Hp, m, tol, speye(size(Gnf)));
</pre><pre class="codeoutput">	Iteration: 1, residual: 4.454880e-001
	Iteration: 2, residual: 3.003006e-001
	Iteration: 3, residual: 1.234620e-001
	Iteration: 4, residual: 3.913409e-002
	Iteration: 5, residual: 2.714825e-002
	Iteration: 6, residual: 2.462790e-002
	Iteration: 7, residual: 2.216687e-002
	Iteration: 8, residual: 2.000439e-002
	Iteration: 9, residual: 1.953523e-002
	Iteration: 10, residual: 1.923569e-002
	Iteration: 11, residual: 1.890274e-002
	Iteration: 12, residual: 1.757445e-002
	Iteration: 13, residual: 1.359434e-002
	Iteration: 14, residual: 1.265646e-002
	Iteration: 15, residual: 8.420311e-003
	Iteration: 16, residual: 6.443942e-003
	Iteration: 17, residual: 4.782193e-003
	Iteration: 18, residual: 3.576773e-003
	Iteration: 19, residual: 2.965318e-003
	Iteration: 20, residual: 2.541211e-003
	Iteration: 21, residual: 1.940346e-003
	Iteration: 22, residual: 1.605770e-003
	Iteration: 23, residual: 1.390790e-003
	Iteration: 24, residual: 1.177304e-003
	Iteration: 25, residual: 9.040387e-004
</pre><p>The solution is plotted with the toolbox function <tt>plot_mesh</tt>, and is compared with the analytical solution
         </p><pre class="codeinput">e = norm(qs-qs0)/norm(qs0); <span class="comment">% relative error</span>

figure;
plot_mesh(mesh, real(qs)); view(3);
title(sprintf(<span class="string">'Error: %.2e'</span>, e));
</pre><img vspace="5" hspace="5" src="sph_trans_dir_04.png" alt=""> <p class="footer"><br>
            Published with MATLAB&reg; 7.8<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Exterior Dirichlet radiation problem
% This tutorial shows how to use the toolbox |NIHU| to compute a simple
% acoustic radiation problem with Dirichlet boundary condition.

%% Mesh generation
% Use a toolbox function |create_sphere_boundary| to create a sphere mesh
% with given radius and division parameter. Determine maximal wavelength
% applicable to the mesh with a given element-per-wavelength ratio, using
% the toolbox function |bemkmax|
R = 1;      % radius
nR = 20;    % division parameter
mesh = create_sphere_boundary(R, nR);
ratio = 7;  % element-per-wavelength ratio
kmax = bemkmax(mesh, ratio);
k = min(kmax);

figure;
plot_mesh(mesh, kmax); view(3);

%% Excitation
% The excitation will be the pressure field of a point source
% located inside the sphere, slightly shifed from the center.
% Constant elements are used with one DOF located at the element centers,
% so the pressure is computed in the element center locations. For error
% analysis purposes, the analytical pressure derivative values are also
% computed.
% The element centers and normals are determined by
% a toolbox function |centnorm|, and the incident wave field is computed by
% the toolbox function |incident|.
r0 = [-.2 0 0];                    % location of the source monopole
[cent, normal] = centnorm(mesh);   % element centers and normals
[ps, qs0] = incident('point', r0, cent, normal, k);

figure;
plot_mesh(mesh, ps); view(3); colorbar;

%% Build cluster tree
% The cluster tree is built with the toolbox function |clustertree|. The
% depth of the tree is determined by the mesh's dimensions and
% the minimal dimensionless cluster size at the leaf level as
%
% $$ depth = \log_2 \frac{2kR}{kd_{\mathrm{min}}}$$
%
kdmin = 3;  % minimal dimensionless cluster size at leaf level
kD = 2*k*R; % mesh dimension
depth = round(log2(kD/kdmin));
[tree, fs, fr] = clustertree(depth, cent);

%% Sparse matrices
% The near field sparse bem matrices are determined by the toolbox function
% |bemHG|. The sparsity structure (location of nonzeros) of these matrices
% is determined using the cluster tree by the toolbox function |nfij|
[i, j] = nfij(tree(end).nearfield, tree(end).nodsou);
[Hnf, Gnf] = bemHG(mesh, k, 'const', [], [i j]);

figure;
spy(Hnf);

%% FMM integration parameters
% The expansion lengths, the quadrature points over the unit sphere and the
% precomputed translation operators and interpolation matrices are
% generated by the toolbox function |integpar|.
C = 3;  % Accuracy parameter related to the expansion length
I = integpar(tree, k, C);

%% BEM spatial quadrature and relative tree
% The Gaussian integration points and weights on the surface are computed
% by the toolbox function |geo2gauss|. The parameters of the function are
% the mesh and the quadrature points for triangles and quadrangles,
% respectively.
%
% In order to optimally use the C (MEX) code, the tree is converted into a
% relative tree that contains distances between entries rather than
% absolute locations.
[t, gs, gn, w, gind] = geo2gauss(mesh, [3 9]);
[tr, rr, rs, ns] = reltree(tree, cent, fr, gs, fs(gind), gn);

%% Solution
% The right hand side of the linear system of equations is computed now.
% The near field part is computed by multiplication by the near field
% matrix, the far field contribution is computed by means of the MLFMA,
% using the toolbox function |mpcont_Gq|.
Hp = Hnf*ps + -2*pi*ps + ...
    mpcont_Hp(rr, rs, ns, ps(gind).*w, tr, I, k, fs(gind), fr);

%% 
% The iterative solution of the system of equations is computed by the
% toolbox function |my_gmres|, where the matrix-vector products are
% evaluated by the toolbox function |gmres_iter_dirichlet|.
m = 100;        % max. number of iterations
tol = 1e-3;     % prescribed backward relative tolerance
[qs, eps] = my_gmres(...
    @(q) gmres_iter_dirichlet(q, Gnf, rr, rs, w, gind, tr, I, k, fs, fr),...
    Hp, m, tol, speye(size(Gnf)));

%% 
% The solution is plotted with the toolbox function |plot_mesh|, and is
% compared with the analytical solution
e = norm(qs-qs0)/norm(qs0); % relative error

figure;
plot_mesh(mesh, real(qs)); view(3);
title(sprintf('Error: %.2e', e));
##### SOURCE END #####
-->
   </body>
</html>