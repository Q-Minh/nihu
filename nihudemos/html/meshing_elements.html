
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Basic mesh elements</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-06-07"><meta name="DC.source" content="meshing_elements.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h1>Basic mesh elements</h1><!--introduction--><p>This tutorial describes how to create simple meshes using the toolbox <tt>NIHU</tt>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Create a straight line</a></li><li><a href="#4">Create slab</a></li><li><a href="#9">Create circle</a></li><li><a href="#11">Create brick volume and brick surface</a></li><li><a href="#15">Create sphere and sphere surface</a></li><li><a href="#17">Create Cat's eye</a></li></ul></div><h2>Create a straight line<a name="1"></a></h2><p>Simple straight lines can be created using the toolbox function <a href="matlab:doc('create_line')">create_line</a>. There are three different ways of meshing straight lines:</p><div><ul><li>Defining its length <img src="meshing_elements_eq93576.png" alt="$L$"> and the number of elements <img src="meshing_elements_eq14413.png" alt="$n_E$"></li><li>Defining its starting and ending positions <img src="meshing_elements_eq41609.png" alt="${\bf x}_1$"> and <img src="meshing_elements_eq14839.png" alt="${\bf x}_2$">, as well as the number of elements <img src="meshing_elements_eq14413.png" alt="$n_E$"></li><li>Defining the internal nodes <img src="meshing_elements_eq05306.png" alt="${\bf x}_i$"> of the straight line.</li></ul></div><p>In the first example, the first method is applied.</p><pre class="codeinput">L = 5;              <span class="comment">% length of the line</span>
Le = 0.3;           <span class="comment">% approximate length of a line element</span>
N = ceil(L/Le);     <span class="comment">% number of elements</span>
lin = create_line(L, N);

figure;
plot_mesh(lin);
</pre><img vspace="5" hspace="5" src="meshing_elements_01.png" alt=""> <p>The second method can be applied as follows:</p><pre class="codeinput">R = [                               <span class="comment">% start and end locations</span>
    1 0 0
    2 3 1
    ];
Le = 0.3;                           <span class="comment">% approx. length of a line element</span>
N = ceil(norm(diff(R,[],1))/Le);    <span class="comment">% number of elements</span>
lin = create_line(R, N);

figure;
plot_mesh(lin); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_02.png" alt=""> <p>In the third method, the line's nodes <img src="meshing_elements_eq05306.png" alt="${\bf x}_i$"> are directly defined. In this case, the line is aligned along the <img src="meshing_elements_eq43551.png" alt="$x$"> axis.</p><pre class="codeinput">Cx = -1:.1:+2;          <span class="comment">% internal nodes</span>
lin = create_line(Cx);

figure;
plot_mesh(lin);
</pre><img vspace="5" hspace="5" src="meshing_elements_03.png" alt=""> <h2>Create slab<a name="4"></a></h2><p>Rectangular slabs can be created using the toolbox function <a href="matlab:doc('create_slab')">create_slab</a>. There are three ways of defining slabs:</p><div><ul><li>Define its side lengths <img src="meshing_elements_eq78525.png" alt="$L_x$"> and <img src="meshing_elements_eq32514.png" alt="$L_y$">, and the number of elements <img src="meshing_elements_eq81641.png" alt="$N_x$"> and <img src="meshing_elements_eq37935.png" alt="$N_y$"></li><li>Define its corner nodes <img src="meshing_elements_eq05306.png" alt="${\bf x}_i$">, <img src="meshing_elements_eq05994.png" alt="$i = 1 \dots 4$"> and the number of elements along the two dimensions.</li><li>Define the internal nodes <img src="meshing_elements_eq01017.png" alt="$x_i$">, <img src="meshing_elements_eq98674.png" alt="$y_j$"> directly, so that the slab's nodes are elements of the Descartes product <img src="meshing_elements_eq89402.png" alt="$x_i \times y_j$">.</li></ul></div><p>In the first case, the slab is located at the origin, its sides are aligned along the <img src="meshing_elements_eq43551.png" alt="$x$"> and <img src="meshing_elements_eq44020.png" alt="$y$"> axes.</p><pre class="codeinput">L = [4 3];                  <span class="comment">% side lengths</span>
Le = .3;                    <span class="comment">% approximate side length of an element</span>
N = ceil(L/Le);             <span class="comment">% number of elements along the two sides</span>
slab = create_slab(L, N);

figure;
plot_mesh(slab);
</pre><img vspace="5" hspace="5" src="meshing_elements_04.png" alt=""> <p>The parameters <tt>L</tt> and <tt>N</tt> can be defined as scalars, so that the same meshing parameters are used in the two directions.</p><pre class="codeinput">slab = create_slab(4, 7);

figure;
plot_mesh(slab);
</pre><img vspace="5" hspace="5" src="meshing_elements_05.png" alt=""> <p>In the second method, the four corner nodes are defined in the 4x3 matrix <tt>C</tt>.</p><pre class="codeinput">C = [                       <span class="comment">% corner coordinates</span>
    0  0 0
    1  0 0
    .7  1 1
    .2 .7 0
    ];
N = [10 7];                 <span class="comment">% division parameters</span>
slab = create_slab(C, N);
figure;
plot_mesh(slab); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_06.png" alt=""> <p>With the third method, non-uniformly meshed slabs can be easily defined as follows:</p><pre class="codeinput">Cx = logspace(1, 2, 30);    <span class="comment">% internal nodes along the x axis</span>
Cy = linspace(10, 30, 10);  <span class="comment">% internal nodes along the y axis</span>
slab = create_slab(Cx, Cy);

figure;
plot_mesh(slab);
</pre><img vspace="5" hspace="5" src="meshing_elements_07.png" alt=""> <p>If only <tt>Cx</tt> is defined, the same nodes are applied for both dimensions:</p><pre class="codeinput">Cx = logspace(1, 2, 20);    <span class="comment">% internal nodes along the x and y axes</span>
slab = create_slab(Cx);

figure;
plot_mesh(slab);
</pre><img vspace="5" hspace="5" src="meshing_elements_08.png" alt=""> <h2>Create circle<a name="9"></a></h2><p>Circle quadrants can be meshed by using the function <a href="matlab:doc('create_circle_quadrant')">create_circle_quadrant</a>. The necessary parameters are the circle's radius <img src="meshing_elements_eq85930.png" alt="$R$"> and a division parameter <img src="meshing_elements_eq04645.png" alt="$n_R$">. The division parameter defines the number of elements along the radius of the circle quadrant, the same as the number of elements along the perimeter. The circle quadrant is located in the <img src="meshing_elements_eq54256.png" alt="$xy$"> plane, the center is at the origin, and the sides are aligned along the <img src="meshing_elements_eq43551.png" alt="$x$"> and <img src="meshing_elements_eq44020.png" alt="$y$"> axes.</p><pre class="codeinput">R = 2;      <span class="comment">% radius</span>
nR = 10;    <span class="comment">% division parameter</span>
circlequad = create_circle_quadrant(R, nR);

figure;
plot_mesh(circlequad);
</pre><img vspace="5" hspace="5" src="meshing_elements_09.png" alt=""> <p>Circles can be meshed by using the function <a href="matlab:doc('create_circle')">create_circle</a>. The necessary parameters are the circle's radius <img src="meshing_elements_eq85930.png" alt="$R$"> and a division parameter <img src="meshing_elements_eq04645.png" alt="$n_R$">. The circle is located in the <img src="meshing_elements_eq54256.png" alt="$xy$"> plane, the center being at the origin.  The number of elements along the perimeter is <img src="meshing_elements_eq64950.png" alt="$4 n_R$">.</p><pre class="codeinput">R = 2;      <span class="comment">% radius</span>
nR = 10;    <span class="comment">% division parameter</span>
circle = create_circle(R, nR);

figure;
plot_mesh(circle);
</pre><img vspace="5" hspace="5" src="meshing_elements_10.png" alt=""> <h2>Create brick volume and brick surface<a name="11"></a></h2><p>Bricks volume meshes can be created using the toolbox function <a href="matlab:doc('create_brick')">create_brick</a>. There are three ways of defining brick volumes:</p><div><ul><li>Define its side lengths <img src="meshing_elements_eq78540.png" alt="$[L_x, L_y, L_z]$"> and division paramters <img src="meshing_elements_eq72736.png" alt="$[N_x N_y N_z]$"></li><li>Define its corner nodes <img src="meshing_elements_eq05306.png" alt="${\bf x}_i$">, <img src="meshing_elements_eq28768.png" alt="$i = 1 \dots 8$">,</li><li>Define its internal nodes <img src="meshing_elements_eq01017.png" alt="$x_i$">, <img src="meshing_elements_eq98674.png" alt="$y_j$">, <img src="meshing_elements_eq45771.png" alt="$z_k$"> along the three dimensions</li></ul></div><p>The first method is demonstrated first, where the brick is located in the origin, with sides parallel to the coordinate axes:</p><pre class="codeinput">L = [5 4 3];        <span class="comment">% Brick dimensions [Lx Ly Lz]</span>
Le = .3;            <span class="comment">% element length</span>
N = ceil(L / Le);   <span class="comment">% Division parameter [Nx Ny Nz]</span>
brick = create_brick(L, N);

figure;
plot_mesh(brick); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_11.png" alt=""> <p>The second method makes it possible to define skewed bricks, by defining the corner nodes</p><pre class="codeinput">C = [           <span class="comment">% 8 corner nodes of the brick</span>
    0   0  0
    1   0  0
    1.5 1  0
    -.1 .9 .1
    0   0  1
    1   0  1.2
    1.5 1  1
    -.1 .7 1
    ];
brick = create_brick(C, [10, 10, 10]);

figure;
plot_mesh(brick); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_12.png" alt=""> <p>With the third method, non-uniform sampling can easily be defined:</p><pre class="codeinput">Cx = (.1:.05:1).^2; <span class="comment">% nodes along the x axis</span>
Cy = (.1:.05:1).^3; <span class="comment">% nodes along the y axis</span>
Cz = (.1:.05:1).^4; <span class="comment">% nodes along the z axis</span>
brick = create_brick(Cx, Cy, Cz);

figure;
plot_mesh(brick); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_13.png" alt=""> <p>Brick boundaries can be meshed using the toolbox function <a href="matlab:doc('create_brick_boundary')">create_brick_boundary</a>, by defining the brick dimensions and division parameters.</p><pre class="codeinput">L = [5 4 3];        <span class="comment">% Brick dimensions [Lx Ly Lz]</span>
Le = .3;            <span class="comment">% element length</span>
N = ceil(L / Le);   <span class="comment">% Division parameter [Nx Ny Nz]</span>
brick = create_brick_boundary(L, N);

figure;
plot_mesh(brick); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_14.png" alt=""> <h2>Create sphere and sphere surface<a name="15"></a></h2><p>Spherical volumes can be created using the toolbox function <a href="matlab:doc('create_sphere')">create_sphere</a>, by defining the sphere radius <img src="meshing_elements_eq85930.png" alt="$R$"> and a division parameter <img src="meshing_elements_eq04645.png" alt="$n_R$">. The division parameter defines the number of elements along the sphere radius. The number of elements along the perimeter is <img src="meshing_elements_eq64950.png" alt="$4 n_R$">.</p><pre class="codeinput">R = 2;          <span class="comment">% sphere radius</span>
nR = 10;        <span class="comment">% number of elements along the radius</span>
sphere = create_sphere(R, nR);

figure;
plot_mesh(sphere); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_15.png" alt=""> <p>Sphere boundaries can be created using the toolbox function <a href="matlab:doc('create_sphere_boundary')">create_sphere_boundary</a>, by defining the sphere radius <img src="meshing_elements_eq85930.png" alt="$R$"> and division parameter <img src="meshing_elements_eq04645.png" alt="$n_R$">.</p><pre class="codeinput">R = 2;
nR = 10;
sphere = create_sphere_boundary(R, nR);

figure;
plot_mesh(sphere); view(3);
</pre><img vspace="5" hspace="5" src="meshing_elements_16.png" alt=""> <h2>Create Cat's eye<a name="17"></a></h2><p>Cat's eye surface models can be created using the function <a href="matlab:doc('create_catseye')">create_catseye</a>, by defining the radius <img src="meshing_elements_eq85930.png" alt="$R$"> and division parameter <img src="meshing_elements_eq04645.png" alt="$n_R$">.</p><pre class="codeinput">R = 2;
nR = 10;
cat = create_catseye(R, nR);

figure;
plot_mesh(cat); view([110 35]);
</pre><img vspace="5" hspace="5" src="meshing_elements_17.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% Basic mesh elements
% This tutorial describes how to create simple meshes using the toolbox
% |NIHU|.

%% Create a straight line
% Simple straight lines can be created using the toolbox function
% <matlab:doc('create_line') create_line>. There are three different ways of meshing straight lines:
%
% * Defining its length $L$ and the number of elements $n_E$
% * Defining its starting and ending positions ${\bf x}_1$ and ${\bf x}_2$,
% as well as the number of elements $n_E$
% * Defining the internal nodes ${\bf x}_i$ of the straight line.
%
% In the first example, the first method is applied.
%
L = 5;              % length of the line
Le = 0.3;           % approximate length of a line element
N = ceil(L/Le);     % number of elements
lin = create_line(L, N);

figure;
plot_mesh(lin);

%%
% The second method can be applied as follows:
R = [                               % start and end locations
    1 0 0
    2 3 1
    ];
Le = 0.3;                           % approx. length of a line element
N = ceil(norm(diff(R,[],1))/Le);    % number of elements
lin = create_line(R, N);

figure;
plot_mesh(lin); view(3);

%%
% In the third method, the line's nodes ${\bf x}_i$ are directly defined.
% In this case, the line is aligned along the $x$ axis.
Cx = -1:.1:+2;          % internal nodes
lin = create_line(Cx);

figure;
plot_mesh(lin);


%% Create slab
% Rectangular slabs can be created using the toolbox function
% <matlab:doc('create_slab') create_slab>. There are three ways of defining slabs:
%
% * Define its side lengths $L_x$ and $L_y$, and the number of elements
% $N_x$ and $N_y$
% * Define its corner nodes ${\bf x}_i$, $i = 1 \dots 4$ and the number of
% elements along the two dimensions.
% * Define the internal nodes $x_i$, $y_j$ directly,
% so that the slab's nodes are elements of the Descartes product $x_i \times y_j$.
%
% In the first case, the slab is located at the origin, its sides are
% aligned along the $x$ and $y$ axes.
L = [4 3];                  % side lengths
Le = .3;                    % approximate side length of an element
N = ceil(L/Le);             % number of elements along the two sides
slab = create_slab(L, N);

figure;
plot_mesh(slab);

%%
% The parameters |L| and |N| can be defined as scalars, so that the same
% meshing parameters are used in the two directions.
slab = create_slab(4, 7);

figure;
plot_mesh(slab);

%%
% In the second method, the four corner nodes are defined in the 4x3 matrix
% |C|.
C = [                       % corner coordinates
    0  0 0
    1  0 0
    .7  1 1
    .2 .7 0
    ];
N = [10 7];                 % division parameters
slab = create_slab(C, N);
figure;
plot_mesh(slab); view(3);

%%
% With the third method, non-uniformly meshed slabs can be easily defined
% as follows:
Cx = logspace(1, 2, 30);    % internal nodes along the x axis
Cy = linspace(10, 30, 10);  % internal nodes along the y axis
slab = create_slab(Cx, Cy);

figure;
plot_mesh(slab);

%%
% If only |Cx| is defined, the same nodes are applied for both dimensions:
Cx = logspace(1, 2, 20);    % internal nodes along the x and y axes
slab = create_slab(Cx);

figure;
plot_mesh(slab);

%% Create circle
% Circle quadrants can be meshed by using the function
% <matlab:doc('create_circle_quadrant') create_circle_quadrant>. The necessary parameters are the circle's
% radius $R$ and a division parameter $n_R$. The division parameter defines
% the number of elements along the radius of the circle quadrant,
% the same as the number of elements along the perimeter. The circle
% quadrant is located in the $xy$ plane, the center is at the origin, and
% the sides are aligned along the $x$ and $y$ axes.
R = 2;      % radius
nR = 10;    % division parameter
circlequad = create_circle_quadrant(R, nR);

figure;
plot_mesh(circlequad);

%%
% Circles can be meshed by using the function <matlab:doc('create_circle') create_circle>. The
% necessary parameters are the circle's radius $R$ and a division
% parameter $n_R$. The circle is located in the $xy$ plane, the center being
% at the origin.  The number of elements along the perimeter is
% $4 n_R$.
R = 2;      % radius
nR = 10;    % division parameter
circle = create_circle(R, nR);

figure;
plot_mesh(circle);

%% Create brick volume and brick surface
% Bricks volume meshes can be created using the toolbox function
% <matlab:doc('create_brick') create_brick>.
% There are three ways of defining brick volumes:
%
% * Define its side lengths $[L_x, L_y, L_z]$ and division paramters $[N_x N_y N_z]$
% * Define its corner nodes ${\bf x}_i$, $i = 1 \dots 8$,
% * Define its internal nodes $x_i$, $y_j$, $z_k$ along the three dimensions
%
% The first method is demonstrated first, where the brick is located in the
% origin, with sides parallel to the coordinate axes:
L = [5 4 3];        % Brick dimensions [Lx Ly Lz]
Le = .3;            % element length
N = ceil(L / Le);   % Division parameter [Nx Ny Nz]
brick = create_brick(L, N);

figure;
plot_mesh(brick); view(3);

%%
% The second method makes it possible to define skewed bricks, by defining
% the corner nodes
C = [           % 8 corner nodes of the brick
    0   0  0
    1   0  0
    1.5 1  0
    -.1 .9 .1
    0   0  1
    1   0  1.2
    1.5 1  1
    -.1 .7 1
    ];
brick = create_brick(C, [10, 10, 10]);

figure;
plot_mesh(brick); view(3);

%%
% With the third method, non-uniform sampling can easily be defined:
Cx = (.1:.05:1).^2; % nodes along the x axis
Cy = (.1:.05:1).^3; % nodes along the y axis
Cz = (.1:.05:1).^4; % nodes along the z axis
brick = create_brick(Cx, Cy, Cz);

figure;
plot_mesh(brick); view(3);

%%
% Brick boundaries can be meshed using the toolbox function
% <matlab:doc('create_brick_boundary') create_brick_boundary>, by defining the brick dimensions and division
% parameters.
L = [5 4 3];        % Brick dimensions [Lx Ly Lz]
Le = .3;            % element length
N = ceil(L / Le);   % Division parameter [Nx Ny Nz]
brick = create_brick_boundary(L, N);

figure;
plot_mesh(brick); view(3);

%% Create sphere and sphere surface
% Spherical volumes can be created using the toolbox function
% <matlab:doc('create_sphere') create_sphere>, by defining the sphere radius $R$ and a division
% parameter $n_R$. The division parameter defines the number of elements
% along the sphere radius. The number of elements along the perimeter is
% $4 n_R$.
R = 2;          % sphere radius
nR = 10;        % number of elements along the radius
sphere = create_sphere(R, nR);

figure;
plot_mesh(sphere); view(3);

%%
% Sphere boundaries can be created using the toolbox function
% <matlab:doc('create_sphere_boundary') create_sphere_boundary>, by defining the sphere radius $R$ and division
% parameter $n_R$.
R = 2;
nR = 10;
sphere = create_sphere_boundary(R, nR);

figure;
plot_mesh(sphere); view(3);

%% Create Cat's eye
% Cat's eye surface models can be created using the function
% <matlab:doc('create_catseye') create_catseye>, by defining the radius $R$ and division parameter $n_R$.
R = 2;
nR = 10;
cat = create_catseye(R, nR);

figure;
plot_mesh(cat); view([110 35]);
##### SOURCE END #####
--></body></html>