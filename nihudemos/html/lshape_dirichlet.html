
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Dirichlet exterior radiation problem</title>
      <meta name="generator" content="MATLAB 7.8">
      <meta name="date" content="2009-11-10">
      <meta name="m-file" content="lshape_dirichlet"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Dirichlet exterior radiation problem</h1>
         <!--introduction-->
         <p>This tutorial introduces how to use the toolbox <tt>NIHU</tt> to solve a simple exterior acoustic radiation problem.
         </p>
         <p>The problem is radiation by an L-shaped object to the infinite exterior space. The boundary conditions are defined as prescribed
            pressure on the surface elements. The pressure values are obtained as the pressure field of an acoustic monopole located inside
            the radiator. This approach makes it possible to compare the computed surface pressure derivatives and external pressure field
            to analytical solutions.
         </p>
         <!--/introduction-->
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Surface mesh generation</a></li>
               <li><a href="#5">Boundary conditions</a></li>
               <li><a href="#6">Generate BEM matrices and solve system</a></li>
               <li><a href="#8">Generate field point mesh</a></li>
               <li><a href="#9">Compute field point pressure</a></li>
            </ul>
         </div>
         <h2>Surface mesh generation<a name="1"></a></h2>
         <p>Generate an L-shaped domain surface mesh. The mesh is generated by constructing a brick volume, subtracting a subbrick from
            one of its edges, and finally extracting the boundary surface of the remaining L-shaped volume mesh.
         </p><pre class="codeinput">mesh = create_brick(1, 20);
expression = sprintf(<span class="string">'y &gt; .5 | z &lt; .5'</span>);
[nodind, elind] = mesh_select(mesh, expression, <span class="string">'ind'</span>);
mesh.Nodes = mesh.Nodes(nodind,:);
mesh.Elements = mesh.Elements(elind,:);
mesh = get_boundary(mesh);
mesh = drop_unused_nodes(mesh);
</pre><p>Check that the mesh is directed outward by plotting the normals with the toolbox function <tt>plot_elem_normals</tt></p><pre class="codeinput">figure;
plot_mesh(mesh);
plot_elem_normals(mesh);
view(3);
</pre><img vspace="5" hspace="5" src="lshape_dirichlet_01.png" alt=""> <p>The maximal applicable frequency is determined by the rule of thumb</p>
         <p><img src="lshape_dirichlet_eq83420.png" alt="$$L_e \le \lambda / 7$$"></p>
         <p>The maximal applicable wave number at each element of the mesh is computed by the toolbox function <tt>bemkmax</tt>.
         </p><pre class="codeinput">ratio = 7;
kmax_elem = bemkmax(mesh, ratio);

figure;
plot_mesh(mesh, kmax_elem); view(3);
c = colorbar; ylabel(c, <span class="string">'k_{max} [1/m]'</span>);
</pre><img vspace="5" hspace="5" src="lshape_dirichlet_02.png" alt=""> <p>The minimum of these values is the overall frequency limit of computations with this mesh. In the present example, the wave
            number is set slightly lower than the maximal applicable wave number.
         </p><pre class="codeinput">kmax = min(kmax_elem);
k = .9*kmax;
</pre><h2>Boundary conditions<a name="5"></a></h2>
         <p>The radiator is modeled as a transparent surface. The model is excited by the pressure wave field <img src="lshape_dirichlet_eq38467.png" alt="$p_s$"> induced by a point source located inside the domain. Constant boundary elements are used with one unknown in each element
            center. The incident wave field is computed by the toolbox function <tt>incident</tt>. For further comparison purposes, the incident normal derivative field <img src="lshape_dirichlet_eq94647.png" alt="$q_{s0}$"> is also computed.
         </p><pre class="codeinput">r0 = [.3 .7 .2];          <span class="comment">% location of the point source</span>
[r, n] = centnorm(mesh);  <span class="comment">% model elem centers and normals</span>
[ps, qs0] = incident(<span class="string">'point'</span>, r0, r, n, k);

figure;
plot_mesh(mesh, real(ps)); view(3);
c = colorbar; ylabel(c, <span class="string">'Real pressure'</span>);
</pre><img vspace="5" hspace="5" src="lshape_dirichlet_03.png" alt=""> <h2>Generate BEM matrices and solve system<a name="6"></a></h2>
         <p>The BEM system matrices are generated by the toolbox function <tt>bemHG</tt>. The system of equations
         </p>
         <p><img src="lshape_dirichlet_eq69235.png" alt="$$ {\bf H} {\bf p}_s = {\bf G} {\bf q}_s $$"></p>
         <p>is solved by direct matrix inversion.</p><pre class="codeinput">[H, G] = bemHG(mesh, k, <span class="string">'const'</span>);   <span class="comment">% Generate BEM matrices</span>
qs = G \ (H * ps);                  <span class="comment">% solve the system</span>
</pre><p>The surface pressure is compared to the analytical solution of the problem.</p><pre class="codeinput">e = norm(qs-qs0)/norm(qs0); <span class="comment">% compute relative error</span>

figure;
plot_mesh(mesh, real(qs)); view(3);
c = colorbar; ylabel(c, <span class="string">'Real surface pressure derivative'</span>);
title(sprintf(<span class="string">'Error: %e'</span>, e));
</pre><img vspace="5" hspace="5" src="lshape_dirichlet_04.png" alt=""> <h2>Generate field point mesh<a name="8"></a></h2>
         <p>The field point mesh is generated by the toolbox function <tt>create_slab</tt>.
         </p><pre class="codeinput">L = [1 1];
Le = 2*pi/k/ratio;
field = create_slab(L, ceil(L/Le));
field = rotate_mesh(field, [0 0 0], [0 -1 0], pi/2);
field = translate_mesh(field, [.5 -.5 .5]);

figure;
plot_mesh(mesh);
plot_mesh(field); view(3);
</pre><img vspace="5" hspace="5" src="lshape_dirichlet_05.png" alt=""> <h2>Compute field point pressure<a name="9"></a></h2>
         <p>The points of the field point mesh are extracted from the structure <tt>field</tt>, and are used to generate the field point BEM matrices with the toolbox function <tt>bemHG</tt>. The field point pressure is computed as
         </p>
         <p><img src="lshape_dirichlet_eq60286.png" alt="$${\bf p}_f = \frac{1}{4\pi} ({\bf H} {\bf p}_s - {\bf G} {\bf q}_s)$$"></p><pre class="codeinput">points = field.Nodes(:,2:4);
[H, G] = bemHG(mesh, k, <span class="string">'const'</span>, points);
pf = (H * ps - G * qs) / (4*pi);
</pre><p>The field point pressure is compared to the analytical solution.</p><pre class="codeinput">pf0 = incident(<span class="string">'point'</span>, r0, points, [], k);
e = norm(pf-pf0)/norm(pf0);

figure;
plot_mesh(mesh, real(ps));
plot_mesh(field, real(pf));
c = colorbar; ylabel(c, <span class="string">'Real pressure'</span>);
title(sprintf(<span class="string">'Error: %e'</span>, e));
view(3);
</pre><img vspace="5" hspace="5" src="lshape_dirichlet_06.png" alt=""> <p class="footer"><br>
            Published with MATLAB&reg; 7.8<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Dirichlet exterior radiation problem
% This tutorial introduces how to use the toolbox |NIHU| to solve a simple
% exterior acoustic radiation problem.
%
% The problem is radiation by an L-shaped object to the infinite exterior
% space. The boundary conditions are defined as prescribed pressure
% on the surface elements. The pressure values are obtained
% as the pressure field of an acoustic monopole located inside the
% radiator. This approach makes it possible to compare the computed
% surface pressure derivatives and external pressure field to analytical
% solutions.

%% Surface mesh generation
% Generate an L-shaped domain surface mesh. The mesh is generated by
% constructing a brick volume, subtracting a subbrick from one of its
% edges, and finally extracting the boundary surface of the remaining
% L-shaped volume mesh.
mesh = create_brick(1, 20);
expression = sprintf('y > .5 | z < .5');
[nodind, elind] = mesh_select(mesh, expression, 'ind');
mesh.Nodes = mesh.Nodes(nodind,:);
mesh.Elements = mesh.Elements(elind,:);
mesh = get_boundary(mesh);
mesh = drop_unused_nodes(mesh);

%%
% Check that the mesh is directed outward by plotting the normals with the
% toolbox function |plot_elem_normals|
figure;
plot_mesh(mesh);
plot_elem_normals(mesh);
view(3);

%%
% The maximal applicable frequency is determined by the rule of thumb
% 
% $$L_e \le \lambda / 7$$
% 
% The maximal applicable wave number at each element of the mesh is
% computed by the toolbox function |bemkmax|.
ratio = 7;
kmax_elem = bemkmax(mesh, ratio);

figure;
plot_mesh(mesh, kmax_elem); view(3);
c = colorbar; ylabel(c, 'k_{max} [1/m]');

%%
% The minimum of these values
% is the overall frequency limit of computations with this mesh.
% In the present example, the wave number is set slightly lower than the
% maximal applicable wave number.
kmax = min(kmax_elem);
k = .9*kmax;

%% Boundary conditions
% The radiator is modeled as a transparent surface. The model is excited
% by the pressure wave field $p_s$ induced by a point source located
% inside the domain.
% Constant boundary elements are used with one unknown in each element
% center. The incident wave field is computed by the toolbox function
% |incident|. For further comparison purposes, the incident normal
% derivative field $q_{s0}$ is also computed.
r0 = [.3 .7 .2];          % location of the point source
[r, n] = centnorm(mesh);  % model elem centers and normals
[ps, qs0] = incident('point', r0, r, n, k);

figure;
plot_mesh(mesh, real(ps)); view(3);
c = colorbar; ylabel(c, 'Real pressure');

%% Generate BEM matrices and solve system
% The BEM system matrices are generated by the toolbox function |bemHG|.
% The system of equations
%
% $$ {\bf H} {\bf p}_s = {\bf G} {\bf q}_s $$
%
% is solved by direct matrix inversion.
[H, G] = bemHG(mesh, k, 'const');   % Generate BEM matrices
qs = G \ (H * ps);                  % solve the system

%%
% The surface pressure is compared to the analytical solution of the
% problem.
e = norm(qs-qs0)/norm(qs0); % compute relative error

figure;
plot_mesh(mesh, real(qs)); view(3);
c = colorbar; ylabel(c, 'Real surface pressure derivative');
title(sprintf('Error: %e', e));

%% Generate field point mesh
% The field point mesh is generated by the toolbox function |create_slab|.
L = [1 1];
Le = 2*pi/k/ratio;
field = create_slab(L, ceil(L/Le));
field = rotate_mesh(field, [0 0 0], [0 -1 0], pi/2);
field = translate_mesh(field, [.5 -.5 .5]);

figure;
plot_mesh(mesh);
plot_mesh(field); view(3);

%% Compute field point pressure
% The points of the field point mesh are extracted from the structure
% |field|, and are used to generate the field point BEM matrices with the
% toolbox function |bemHG|. The field point pressure is computed as
% 
% $${\bf p}_f = \frac{1}{4\pi} ({\bf H} {\bf p}_s - {\bf G} {\bf q}_s)$$
% 
points = field.Nodes(:,2:4);
[H, G] = bemHG(mesh, k, 'const', points);
pf = (H * ps - G * qs) / (4*pi);

%%
% The field point pressure is compared to the analytical solution.
pf0 = incident('point', r0, points, [], k);
e = norm(pf-pf0)/norm(pf0);

figure;
plot_mesh(mesh, real(ps));
plot_mesh(field, real(pf));
c = colorbar; ylabel(c, 'Real pressure');
title(sprintf('Error: %e', e));
view(3);
##### SOURCE END #####
-->
   </body>
</html>