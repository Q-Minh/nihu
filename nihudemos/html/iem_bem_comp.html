
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Comparison of FE+IE and FE+BE for a transparent geometry</title>
      <meta name="generator" content="MATLAB 7.6">
      <meta name="date" content="2009-12-04">
      <meta name="m-file" content="iem_bem_comp"><style>

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Comparison of FE+IE and FE+BE for a transparent geometry</h1>
         <introduction>
            <p>This demo shows a comparison of solutions based on FE+IE method and coupled FE+BE method for a transparent geomtetry.</p>
         </introduction>
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Definition of the problem and model generation</a></li>
               <li><a href="#5">Extend the model with infinite elements</a></li>
               <li><a href="#8">Prepare solution computation</a></li>
               <li><a href="#10">Assembly of system matrices</a></li>
               <li><a href="#13">Calculation of the solution</a></li>
               <li><a href="#15">Error analysis and displaying results</a></li>
            </ul>
         </div>
         <h2>Definition of the problem and model generation<a name="1"></a></h2>
         <p>Firstly, acoustical and excitation parameters are defined.</p><pre class="codeinput">rhoair = 1.225;             <span class="comment">% mass density of air</span>
cair   = 343.0;             <span class="comment">% sound velocity in air</span>
psrc   = 1;                 <span class="comment">% source amplitude</span>
x0     = [0.5, 0.5, 0];     <span class="comment">% source location</span>
f      = 100;               <span class="comment">% solution frequency</span>
</pre><p>Then geometry parameters are set.</p><pre class="codeinput">R      = 1;                 <span class="comment">% radius of computational domain</span>
r0     = 1;                 <span class="comment">% inner radius of sphere</span>
dr     = r0/4;              <span class="comment">% element size</span>
</pre><p>Creation of the mesh.</p><pre class="codeinput">model = create_sphere(R+r0,ceil((R+r0)/dr));            <span class="comment">% create a sphere</span>
outsel = [<span class="string">'R &gt; '</span>,num2str(r0-dr/10)];
[outn,oute] = mesh_select(model,outsel,<span class="string">'ind'</span>);          <span class="comment">% select outer part</span>
model.Nodes = model.Nodes(outn,:);
model.Elements = model.Elements(oute,:);
model.Elements = drop_IDs(model);
model.Nodes(:,1) = (1:size(model.Nodes,1)).';           <span class="comment">% renunber nodes</span>
model.Materials = [ 1     1 rhoair   cair     0    0];  <span class="comment">% assign materials</span>
</pre><p>Plotting the model. The model will be cut in the y-z plane to see the inner nodes.</p><pre class="codeinput">plot_mesh(mesh_section(model,[-dr/100 -inf -inf;inf inf inf]));
view(3);
</pre><img vspace="5" hspace="5" src="iem_bem_comp_01.png"> <h2>Extend the model with infinite elements<a name="5"></a></h2>
         <p>Get the outer boundary of the sphere.</p><pre class="codeinput">boundary = get_boundary(model);
b_sel = [<span class="string">'R &gt; '</span>,num2str(r0+R-dr/10)];
[bn_ind,be_ind] = mesh_select(boundary,b_sel,<span class="string">'ind'</span>);
boundary.Nodes = boundary.Nodes(bn_ind,:);
boundary.Elements = boundary.Elements(be_ind,:);
</pre><p>The mesh for the infinite elements will be generated as a projection of the boundary surface. This is performed using function
            <a href="matlab:doc('project_ie_mesh')">project_ie_mesh</a>. The centre of the sphere will be used as projection point.
         </p><pre class="codeinput">P = 5;
ie_mesh = project_ie_mesh(boundary,P,<span class="string">'point'</span>,[0 0 0]);
ie_mesh.Elements(:,4) = 2;
ie_mesh.Properties(2,1:6) = [2,2,P,1,0,0];
ie_model = join_meshes(model,ie_mesh);
ie_model = merge_coincident_nodes(ie_model,1e-5);
</pre><p>Plot the extended model</p><pre class="codeinput">plot_mesh(mesh_section(ie_mesh,[-dr/100 -inf -inf;inf inf inf])); alpha <span class="string">.5</span>;
plot_mesh(mesh_section(model,[-dr/100 -inf -inf;inf inf inf])); view(3);
</pre><img vspace="5" hspace="5" src="iem_bem_comp_02.png"> <h2>Prepare solution computation<a name="8"></a></h2>
         <p>Select nodes for solution and excitation</p><pre class="codeinput">e_sel = [<span class="string">'R &lt; '</span>,num2str(r0+dr/3)];
e_ie_ind = mesh_select(ie_model,e_sel,<span class="string">'ind'</span>);    <span class="comment">% excitation nodes (FE/IE)</span>
e_fb_ind = mesh_select(model,   e_sel,<span class="string">'ind'</span>);    <span class="comment">% excitation nodes (FE/BE)</span>
s_sel = [<span class="string">'R &gt; '</span>,num2str(r0+2*dr/3)];
s_ie_ind = mesh_select(ie_model,s_sel,<span class="string">'ind'</span>);    <span class="comment">% solution nodes (FE/IE)</span>
s_fb_ind = mesh_select(model,   s_sel,<span class="string">'ind'</span>);    <span class="comment">% solution nodes (FE/BE)</span>
m_sel = [<span class="string">'(R &lt; '</span>,num2str(r0+R-dr/10),<span class="string">') &amp; (R &gt;'</span>, num2str(r0+dr/10),<span class="string">')'</span>];
m_fb_ind = mesh_select(model,m_sel,<span class="string">'ind'</span>);       <span class="comment">% inside nodes</span>
fe_sel = [<span class="string">'R &lt; '</span>,num2str(r0+R+dr/3)];
fe_ind = mesh_select(ie_model,fe_sel,<span class="string">'ind'</span>);     <span class="comment">% select FE nodes</span>
</pre><p>Determine analytical solution</p><pre class="codeinput">rNod_ie = sqrt(dot(ie_model.Nodes(:,2:4)-repmat(x0,size(ie_model.Nodes,1),1),<span class="keyword">...</span>
                   ie_model.Nodes(:,2:4)-repmat(x0,size(ie_model.Nodes,1),1),2));
rNod_fb = sqrt(dot(model.Nodes(:,2:4)-repmat(x0,size(model.Nodes,1),1),<span class="keyword">...</span>
                   model.Nodes(:,2:4)-repmat(x0,size(model.Nodes,1),1),2));
p_ie = zeros(size(ie_model.Nodes,1),1);
p_fb = zeros(size(model.Nodes,1),1);
p_an_ie = psrc*exp(-1i*(2*pi*f/cair)*rNod_ie)./(rNod_ie);
p_an_fb = psrc*exp(-1i*(2*pi*f/cair)*rNod_fb)./(rNod_fb);
</pre><h2>Assembly of system matrices<a name="10"></a></h2>
         <p>System matrices are assembled for both methods. For the infinite element method mass (MIE), stiffness (KIE) and damping (CIE)
            matrices of the extended model are generated, which are frequency independent sparse matrices. The coupled FE+BE method requires
            the mass (MFB) and stiffness (KFB) matrices of the FE model, and H and G matrices of the boundary model to be computed. The
            excitation matrix (QFB) is also assembled.
         </p>
         <p>Then the system matrices are united. In the FE/BE case the FE system matrix is extended with the coupling matrix determined
            by the BEM.
         </p><pre class="codeinput">disp(<span class="string">'Assembling FEM+IEM matrices:'</span>);tic;
[MIE, KIE, CIE, DOF] = model_mk(ie_model);
SIE = KIE + 1i*2*pi*f*CIE - (2*pi*f)^2*MIE;toc;     <span class="comment">% FE/IE system matrix;</span>
disp(<span class="string">'Assembling FEM+BEM matrices:'</span>);tic;
[MFB, KFB] = model_mk(model);
[QFB, ADOF] = model_a(get_boundary(model));
[H,G] = bemHG(boundary,2*pi*f/cair,<span class="string">'lin'</span>);
SFB = KFB                 - (2*pi*f)^2*MFB;      <span class="comment">% FE/BE system matrix</span>
SFB([m_fb_ind;bn_ind],bn_ind) = SFB([m_fb_ind;bn_ind],bn_ind) - <span class="keyword">...</span>
    1/rhoair*QFB([m_fb_ind;bn_ind],bn_ind)*(G\H);toc;
</pre><pre class="codeoutput">Assembling FEM+IEM matrices:
Elapsed time is 29.140335 seconds.
Assembling FEM+BEM matrices:
Elapsed time is 434.191816 seconds.
</pre><p>Check out the system matrices FE/IE system matrix</p><pre class="codeinput">spy(SIE);
</pre><img vspace="5" hspace="5" src="iem_bem_comp_03.png"> <p>FE/BE system matrix</p><pre class="codeinput">spy(SFB);
</pre><img vspace="5" hspace="5" src="iem_bem_comp_04.png"> <h2>Calculation of the solution<a name="13"></a></h2>
         <p>Creating the excitation vector</p><pre class="codeinput">eDOF = ismember(DOF,ie_model.Nodes(e_ie_ind,1));    <span class="comment">% DOF indexing</span>
sDOF = ismember(DOF,ie_model.Nodes(s_ie_ind,1));
DOFe = e_ie_ind(ismember(ie_model.Nodes(e_ie_ind,1),DOF));
DOFs = s_ie_ind(ismember(ie_model.Nodes(s_ie_ind,1),DOF));
p_ie(DOFe) = p_an_ie(DOFe);
p_fb(e_fb_ind) = p_an_fb(e_fb_ind);
</pre><p>Solution by both models</p><pre class="codeinput">disp(<span class="string">'Solution with infinite elements:'</span>);tic;
p_ie(DOFs) = -SIE(sDOF,sDOF)\SIE(sDOF,eDOF)*p_ie(DOFe);toc;
disp(<span class="string">'Solution with coupled model:'</span>);tic;
p_fb(s_fb_ind) = -SFB(s_fb_ind,s_fb_ind)\SFB(s_fb_ind,e_fb_ind)*p_fb(e_fb_ind); toc;
</pre><pre class="codeoutput">Solution with infinite elements:
Elapsed time is 84.885445 seconds.
Solution with coupled model:
Elapsed time is 313.693368 seconds.
</pre><h2>Error analysis and displaying results<a name="15"></a></h2>
         <p>Calculate near field normal error</p><pre class="codeinput">eni = norm(p_ie(fe_ind)-p_an_ie(fe_ind))/norm(p_an_ie(fe_ind));
enb = norm(p_fb-p_an_fb)/norm(p_an_fb);
maxei = max(abs(p_ie(fe_ind)-p_an_ie(fe_ind))./abs(p_an_ie(fe_ind)));
maxeb = max(abs(p_fb-p_an_fb)./abs(p_an_fb));
maxe = max([maxei,maxeb]);
disp([<span class="string">'Relative L2 norm of IE/FE solution: '</span>,num2str(eni)]);
disp([<span class="string">'Relative L2 norm of FE/BE solution: '</span>,num2str(enb)]);
</pre><pre class="codeoutput">Relative L2 norm of IE/FE solution: 0.010773
Relative L2 norm of FE/BE solution: 0.017174
</pre><p>Plot the IE/FE solution</p><pre class="codeinput">[plot_nind,plot_eind] = mesh_select(ie_model,fe_sel,<span class="string">'ind'</span>);
plot_model = ie_model;
plot_model.Nodes = plot_model.Nodes(plot_nind,:);
plot_model.Elements = plot_model.Elements(plot_eind,:);
subplot(121);
plot_mesh(mesh_section(plot_model,[-inf -inf -inf;dr/100 inf inf]),<span class="keyword">...</span>
    abs(p_ie(fe_ind)-p_an_ie(fe_ind))./abs(p_an_ie(fe_ind)));
hold <span class="string">on</span>;plot3(x0(1),x0(2),x0(3),<span class="string">'r.'</span>);hold <span class="string">off</span>;
view(3);caxis([0 maxe]);
subplot(122);
plot_mesh(mesh_section(plot_model,[-dr/100 -inf -inf;inf inf inf]),<span class="keyword">...</span>
    abs(p_ie(fe_ind)-p_an_ie(fe_ind))./abs(p_an_ie(fe_ind)));
hold <span class="string">on</span>;plot3(x0(1),x0(2),x0(3),<span class="string">'r.'</span>);hold <span class="string">off</span>;
view(3);caxis([0 maxe]);
</pre><img vspace="5" hspace="5" src="iem_bem_comp_05.png"> <p>Plot the FE/BE solution</p><pre class="codeinput">subplot(121);
plot_mesh(mesh_section(model,[-inf -inf -inf;dr/100 inf inf]),<span class="keyword">...</span>
    abs(p_fb-p_an_fb)./abs(p_an_fb));
hold <span class="string">on</span>;plot3(x0(1),x0(2),x0(3),<span class="string">'r.'</span>);hold <span class="string">off</span>;
view(3);caxis([0 maxe]);
subplot(122);
plot_mesh(mesh_section(model,[-dr/100 -inf -inf;inf inf inf]),<span class="keyword">...</span>
    abs(p_fb-p_an_fb)./abs(p_an_fb));
hold <span class="string">on</span>;plot3(x0(1),x0(2),x0(3),<span class="string">'r.'</span>);hold <span class="string">off</span>;
view(3);caxis([0 maxe]);
</pre><img vspace="5" hspace="5" src="iem_bem_comp_06.png"> <p class="footer"><br>
            Published with MATLAB&reg; 7.6<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Comparison of FE+IE and FE+BE for a transparent geometry
%
% This demo shows a comparison of solutions based on FE+IE method and 
% coupled FE+BE method for a transparent geomtetry.
%% Definition of the problem and model generation
% Firstly, acoustical and excitation parameters are defined.
rhoair = 1.225;             % mass density of air
cair   = 343.0;             % sound velocity in air
psrc   = 1;                 % source amplitude
x0     = [0.5, 0.5, 0];     % source location
f      = 100;               % solution frequency
%% 
% Then geometry parameters are set.
R      = 1;                 % radius of computational domain
r0     = 1;                 % inner radius of sphere
dr     = r0/4;              % element size
%% 
% Creation of the mesh.
model = create_sphere(R+r0,ceil((R+r0)/dr));            % create a sphere
outsel = ['R > ',num2str(r0-dr/10)];
[outn,oute] = mesh_select(model,outsel,'ind');          % select outer part
model.Nodes = model.Nodes(outn,:);
model.Elements = model.Elements(oute,:);
model.Elements = drop_IDs(model);
model.Nodes(:,1) = (1:size(model.Nodes,1)).';           % renunber nodes
model.Materials = [ 1     1 rhoair   cair     0    0];  % assign materials
%% 
% Plotting the model. The model will be cut in the y-z plane to see the
% inner nodes.
plot_mesh(mesh_section(model,[-dr/100 -inf -inf;inf inf inf]));
view(3);
%% Extend the model with infinite elements 
% Get the outer boundary of the sphere.
boundary = get_boundary(model);
b_sel = ['R > ',num2str(r0+R-dr/10)];
[bn_ind,be_ind] = mesh_select(boundary,b_sel,'ind');
boundary.Nodes = boundary.Nodes(bn_ind,:);
boundary.Elements = boundary.Elements(be_ind,:);
%%
% The mesh for the infinite elements will be generated as a projection of
% the boundary surface. This is performed using function <matlab:doc('project_ie_mesh') project_ie_mesh>.
% The centre of the sphere will be used as projection point.
P = 5;
ie_mesh = project_ie_mesh(boundary,P,'point',[0 0 0]);
ie_mesh.Elements(:,4) = 2;
ie_mesh.Properties(2,1:6) = [2,2,P,1,0,0];
ie_model = join_meshes(model,ie_mesh);
ie_model = merge_coincident_nodes(ie_model,1e-5);
%% 
% Plot the extended model
plot_mesh(mesh_section(ie_mesh,[-dr/100 -inf -inf;inf inf inf])); alpha .5;
plot_mesh(mesh_section(model,[-dr/100 -inf -inf;inf inf inf])); view(3);
%% Prepare solution computation
% Select nodes for solution and excitation
e_sel = ['R < ',num2str(r0+dr/3)];
e_ie_ind = mesh_select(ie_model,e_sel,'ind');    % excitation nodes (FE/IE)
e_fb_ind = mesh_select(model,   e_sel,'ind');    % excitation nodes (FE/BE)
s_sel = ['R > ',num2str(r0+2*dr/3)];             
s_ie_ind = mesh_select(ie_model,s_sel,'ind');    % solution nodes (FE/IE)
s_fb_ind = mesh_select(model,   s_sel,'ind');    % solution nodes (FE/BE)
m_sel = ['(R < ',num2str(r0+R-dr/10),') & (R >', num2str(r0+dr/10),')'];
m_fb_ind = mesh_select(model,m_sel,'ind');       % inside nodes
fe_sel = ['R < ',num2str(r0+R+dr/3)];       
fe_ind = mesh_select(ie_model,fe_sel,'ind');     % select FE nodes 
%%
% Determine analytical solution
rNod_ie = sqrt(dot(ie_model.Nodes(:,2:4)-repmat(x0,size(ie_model.Nodes,1),1),...
                   ie_model.Nodes(:,2:4)-repmat(x0,size(ie_model.Nodes,1),1),2));
rNod_fb = sqrt(dot(model.Nodes(:,2:4)-repmat(x0,size(model.Nodes,1),1),...
                   model.Nodes(:,2:4)-repmat(x0,size(model.Nodes,1),1),2));
p_ie = zeros(size(ie_model.Nodes,1),1);
p_fb = zeros(size(model.Nodes,1),1);
p_an_ie = psrc*exp(-1i*(2*pi*f/cair)*rNod_ie)./(rNod_ie);
p_an_fb = psrc*exp(-1i*(2*pi*f/cair)*rNod_fb)./(rNod_fb);
%% Assembly of system matrices
%
% System matrices are assembled for both methods. For the infinite element
% method mass (MIE), stiffness (KIE) and damping (CIE) matrices of the 
% extended model are generated, which are frequency independent sparse 
% matrices. The coupled FE+BE method requires the mass (MFB) and stiffness
% (KFB) matrices of the FE model, and H and G matrices of the boundary
% model to be computed. The excitation matrix (QFB) is also assembled.
%
% Then the system matrices are united. In the FE/BE case the FE system 
% matrix is extended with the coupling matrix determined by the BEM.
%
disp('Assembling FEM+IEM matrices:');tic;
[MIE, KIE, CIE, DOF] = model_mk(ie_model);
SIE = KIE + 1i*2*pi*f*CIE - (2*pi*f)^2*MIE;toc;     % FE/IE system matrix;
disp('Assembling FEM+BEM matrices:');tic;
[MFB, KFB] = model_mk(model);
[QFB, ADOF] = model_a(get_boundary(model));
[H,G] = bemHG(boundary,2*pi*f/cair,'lin');
SFB = KFB                 - (2*pi*f)^2*MFB;      % FE/BE system matrix
SFB([m_fb_ind;bn_ind],bn_ind) = SFB([m_fb_ind;bn_ind],bn_ind) - ...
    1/rhoair*QFB([m_fb_ind;bn_ind],bn_ind)*(G\H);toc;
%%
% Check out the system matrices
% FE/IE system matrix
spy(SIE);
%%
% FE/BE system matrix
spy(SFB);
%% Calculation of the solution
% Creating the excitation vector
eDOF = ismember(DOF,ie_model.Nodes(e_ie_ind,1));    % DOF indexing
sDOF = ismember(DOF,ie_model.Nodes(s_ie_ind,1));
DOFe = e_ie_ind(ismember(ie_model.Nodes(e_ie_ind,1),DOF));
DOFs = s_ie_ind(ismember(ie_model.Nodes(s_ie_ind,1),DOF));
p_ie(DOFe) = p_an_ie(DOFe);
p_fb(e_fb_ind) = p_an_fb(e_fb_ind);
%%
% Solution by both models
disp('Solution with infinite elements:');tic;
p_ie(DOFs) = -SIE(sDOF,sDOF)\SIE(sDOF,eDOF)*p_ie(DOFe);toc;
disp('Solution with coupled model:');tic;
p_fb(s_fb_ind) = -SFB(s_fb_ind,s_fb_ind)\SFB(s_fb_ind,e_fb_ind)*p_fb(e_fb_ind); toc;
%% Error analysis and displaying results 
% Calculate near field normal error
eni = norm(p_ie(fe_ind)-p_an_ie(fe_ind))/norm(p_an_ie(fe_ind));
enb = norm(p_fb-p_an_fb)/norm(p_an_fb);
maxei = max(abs(p_ie(fe_ind)-p_an_ie(fe_ind))./abs(p_an_ie(fe_ind)));
maxeb = max(abs(p_fb-p_an_fb)./abs(p_an_fb));
maxe = max([maxei,maxeb]);
disp(['Relative L2 norm of IE/FE solution: ',num2str(eni)]);
disp(['Relative L2 norm of FE/BE solution: ',num2str(enb)]);
%%
% Plot the IE/FE solution
[plot_nind,plot_eind] = mesh_select(ie_model,fe_sel,'ind');
plot_model = ie_model;
plot_model.Nodes = plot_model.Nodes(plot_nind,:);
plot_model.Elements = plot_model.Elements(plot_eind,:);
subplot(121);
plot_mesh(mesh_section(plot_model,[-inf -inf -inf;dr/100 inf inf]),...
    abs(p_ie(fe_ind)-p_an_ie(fe_ind))./abs(p_an_ie(fe_ind)));
hold on;plot3(x0(1),x0(2),x0(3),'r.');hold off;
view(3);caxis([0 maxe]);
subplot(122);
plot_mesh(mesh_section(plot_model,[-dr/100 -inf -inf;inf inf inf]),...
    abs(p_ie(fe_ind)-p_an_ie(fe_ind))./abs(p_an_ie(fe_ind)));
hold on;plot3(x0(1),x0(2),x0(3),'r.');hold off;
view(3);caxis([0 maxe]);
%%
% Plot the FE/BE solution
subplot(121);
plot_mesh(mesh_section(model,[-inf -inf -inf;dr/100 inf inf]),...
    abs(p_fb-p_an_fb)./abs(p_an_fb));
hold on;plot3(x0(1),x0(2),x0(3),'r.');hold off;
view(3);caxis([0 maxe]);
subplot(122);
plot_mesh(mesh_section(model,[-dr/100 -inf -inf;inf inf inf]),...
    abs(p_fb-p_an_fb)./abs(p_an_fb));
hold on;plot3(x0(1),x0(2),x0(3),'r.');hold off;
view(3);caxis([0 maxe]);
##### SOURCE END #####
-->
   </body>
</html>