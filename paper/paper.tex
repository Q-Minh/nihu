\documentclass[review]{elsarticle}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,bm,amsfonts}

\newcommand{\td}{\mathrm{d}}

\title{Boonen13}
\author{Peter Fiala, Peter Rucz}

\begin{document}

\maketitle

\section{Introduction}

\section{Theory}

\begin{equation}
R_{ij} = \int_S \int_S N_i(\bm{x}) K(\bm{x},\bm{y}) M_j(\bm{y}) \td \bm{y} \td \bm{x}
\end{equation}

\section{Software structure}

\subsection{The representation of function spaces}

The following structural description follows a bottom-up concept to introduce the software's main classes that are used to define the test and trial function spaces.

\subsubsection{Space and Domain}

Class Space is used to model a real or complex coordinate space.
The class defines a scalar type and the type of a location vector in the space.

Class Domain models finite subdomains of a coordinate space.
Class Domain is templated on class Space and the number of corners of the subdomain.
The class is mainly used to define the reference domains $\mathcal{D}$ by enumerating its corner locations.

\subsubsection{ShapeSet}

Class ShapeSet implements interpolation functions defined over a Domain.
Class ShapeSet is templated on its Domain and the number of interpolation functions.
The class is able to compute the shape function $L_k(\bm{\xi})$ and its gradient $\nabla L_k(\bm{\xi})$ for an arbitrary location $\bm{\xi}$ in the Domain $\mathcal{D}$.
Furthermore, the shape function class is able to return its nodal locations $\bm{\xi}_i$, which is useful when defining singular quadratures.

\subsubsection{Element}

An element is defined by a reference domain $\mathcal{D}$ and a coordinate transform $\bm{x}(\bm{\xi})$.
Class Element is therefore templated on class Space (the $\bm{x}$-space) and class ShapeSet, and is defined by the nodal locations $\bm{x}_i$.
The class is able to compute the location $\bm{x}(\bm{\xi}) = \sum \bm{x}_i L_i(\bm{\xi})$, its gradient $\nabla \bm{x}(\bm{\xi})  = \sum \bm{x}_i \nabla L_i(\bm{\xi})$, and -- if the dimensionality of the $\bm{x}$-space and the reference space differs by one -- the element normal vector $\bm{n}(\bm{\xi})$.
Furthermore, class Element can compute the Jacobian of the coordinate transform $\bm{x}(\bm{\xi})$.

\subsubsection{Field and FieldView}

In the NiHu terminology, a field is an element extended with an interpolation shape set, the so-called $N$-set.
While the element describes the variation of the geometry over the reference domain, the field describes the variation of a field quantity over the element.
Class Field is templated on class Element and class ShapeSet (the $N$-set).
The class is able to compute the $N$-set values $N_i(\bm{\xi})$, and can return the DOF index of each $N$-set node.
Using this structure, each field defines its block's location in the result matrix of the weighted residual.

In the general case, the geometrical and field interpolation shape sets are independent, and a field stores an element (by reference) and its DOF indices (by value).
In lots of practical applications, however, the field information can be deduced from the element only.
For this reason, NiHu introduces the concept of field views.
A FieldView class is an Element class tagged with (templated to) a field generation option.
NiHu currently implements two field views.
Constant field view means that the $N$-set is a constant shape set of domain $\mathcal{D}$, and the single DOF index is the element's element index.
Isoparametric field view means that the $N$-set equals the element's geometrical interpolation shape set ($L$-set), and the DOF indices are equal to the corner node indices of the element.

\subsubsection{Mesh}

The mesh is the discretised model of the weighted residual's domain $S$.
In the fininte element context, the mesh is a set of elements, heterogeneous in the sense that it contains elements of different types (tria, quad, etc).
NiHu splits the mesh up into homogeneous submeshes, each submesh containing elements of the same kind, stored by value in a vector container.
The advantage of this technique is that traversing and processing a submesh can be done without dynamic dispatching, allowing the programmer to work with different function interfaces for different elements, and allowing the compiler to inline and optimise function calls and unroll loops within a submesh.

Class Mesh itself is a heterogoneous container of homogeneous submeshes that provides element-specific iterator ranges for all the element types.
The implementation is based on an inheritence scheme, where the heterogeneous Mesh is derived from homogeneous submeshes:

\begin{verbatim}
class Mesh :
    public std::vector<TriaElem>,
    public std::vector<QuadElem>,
    public std::vector<OtherElem>
{
public:
    template <class Elem>	
    typename std::vector<Elem>::iterator elem_begin(void)
    {
        return std::vector<Elem>::begin();
    }
    
    ...
};
\end{verbatim}

In the actual implementation, class Mesh is templated on a compile time vector of element types, and the above introduced inheritance scheme is automatically generated using template metaprogramming.
When the mesh is being built from run-time mesh description inputs, TMP-generated conditionals are used to construct and insert the elements into their submeshes.
Similarly, when all elements of a heterogeneous mesh are traversed, TMP-generated code is applied to sequentially traverse the homogeneous submeshes.
This approach totally mitigates dynamic dispatching, and allows the compiler to optimise the resulting code.


\subsubsection{FunctionSpace and FunctionSpaceView}

As the mesh is a heterogeneous container of elements, the function space is a heterogeneous container of fields.
Class FunctionSpace is implemented using the same structure as class Mesh: it is a heterogeneous container of homogeneous sub-functionspaces, each templated to a specific field type.
Class FunctionSpace is templated on a compile time vector of field types, and provides iterator ranges for each field type.

Similar to field views, NiHu provides a simple mechanism to automatically generate function spaces from meshes.
In lots of engineering applications it is sufficient to use a single geometry and extend all of its elements to constant or isoparametric fields, resulting in a -- not necessarily homogeneous -- constant or isoparametric function space.
The resulting classes are called FunctionSpaceView classes, and they implement the function space interface.
FunctionSpaceView classes are implemented by overriding the Mesh's element iterators to field view iterators that traverse the mesh's elements, but return field view's when dereferenced.
This concept is implemented with no additional runtime computational cost and memory requirement, that becomes really useful when a mesh is extended into different kinds of function space views at the same time, and the two function space views are used in the weighted residual approach as test and trial function spaces.


\subsection{Evaluating the kernel}


\subsubsection{Kernel and KernelInput}

The kernel $K(\bm{x},\bm{y})$ of the weighted residual can be evaluated in points $\bm{x}$ and $\bm{y}$ of the mesh.
In order to achieve an easily configurable kernel entity, NiHu defines class Kernel to implement the bivariate function $K(\gamma_1, \gamma_2)$, where the two variables $\gamma_1$ and $\gamma_2$ are instances of different KernelInput classes.

KernelInput classes are templated on the $\bm{x}$-space, and can be constructed using an element and a numerical quadrature base point with a templated constructor.
The simplest useful KernelInput is a location: $\gamma = \bm{x}$. A more complex often used KernelInput class can be defined by storing the location and the normal: $\gamma = \left\{\bm{x}, \bm{n}(\bm{x}) \right\}$.

Class Kernel not only evaluates the kernel on two KernelInputs, but is capable to estimate the kernel's polynomial complexity between two elements.
This comes in hand when the numerical quadrature order needs to be selected.
Class Kernel further defines the quadrature family (Gaussian for example) used to integrate the kernel, provides information on the kernels singular behavior, and can evaluate alternative regularised schemes for the case of singular kernels.


\subsubsection{Dual kernel evaluation}

In most BEM applications the boundary integral equations are formalised using a set of kernels, consisting of the fundamental solution and its derivatives.
In these applications parallel evaluation of two or more weighted residuals is advantageous if the different kernels share elements of their kernel inputs.
For the case of simple potential problems, even the computational complexity of the Jacobian can be comparable to that of the kernel evaluation, which clearly justifies the necessity of parallel evaluations.

NiHu provides a straightforward and transparent approach for parallel evaluations.
Kernels of different types can be encapsulated in Couple classes.
All the necessary mathematical operations needed to evaluate the weighted residuals are implemented for Couple classes.
By means of expression templates, the Couple arithmetics compiles optimally to sequential evaluation of single-kernel weighted residuals, but repeated evaluation of kernel inputs, $N$-set vectors or Jacobians is avoided.

\subsection{Numerical integration}



\bibliographystyle{unsrt}
\bibliography{}


\end{document}

